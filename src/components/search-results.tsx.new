"use client";

import { JournalReference } from "@/types/search";
import { searchJournals } from "@/app/actions";
import {
  ExternalLink,
  Download,
  BookOpen,
  Search,
  CheckCircle2,
  Brain,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Separator } from "@/components/ui/separator";
import { useEffect, useState } from "react";
import { cn } from "@/lib/utils";
import { marked } from "marked";
import { checkSearchStatus } from "@/lib/api";

interface SearchResultsProps {
  query: string;
  startYear: string;
  endYear: string;
  mode: string;
}

export default function SearchResults({
  query,
  startYear,
  endYear,
  mode,
}: SearchResultsProps) {
  const [searchState, setSearchState] = useState<
    "searching" | "found" | "processing" | "complete"
  >("searching");
  const [progress, setProgress] = useState(0);
  const [journalsFound, setJournalsFound] = useState(0);
  const [result, setResult] = useState<{
    answer: string;
    references: JournalReference[];
    bibliography?: string[];
    taskId?: string;
    phase?: 'waiting' | 'sources' | 'answer' | 'completed';
    answerPending?: boolean;
  } | null>(null);
  
  // Helper untuk normalisasi sumber
  const normalizeSource = (s: any): JournalReference => {
    return {
      title: s.title || s.paper_title || 'Unknown Title',
      authors: Array.isArray(s.authors) ? s.authors : (s.author ? [s.author] : ['Unknown Author']),
      year: s.year ? parseInt(String(s.year)) : new Date().getFullYear(),
      journal: (s.publisher || s.journal || 'Unknown Journal').toUpperCase(),
      doi: s.doi || '',
      url: s.url || '',
      pdfUrl: s.pdfUrl || '',
      abstract: s.teks || s.abstract || '',
    };
  };
  
  useEffect(() => {
    // Polling untuk answer di background jika masih dalam proses
    const pollAnswerInBackground = async (taskId: string) => {
      let retries = 0;
      const maxRetries = 60; // 60 detik max
      
      // Polling interval yang meningkat setelah beberapa percobaan
      const getDelay = (retry: number) => {
        if (retry < 10) return 500; // 0.5 detik untuk 10 percobaan pertama
        if (retry < 20) return 1000; // 1 detik untuk percobaan 11-20
        return 2000; // 2 detik untuk percobaan selanjutnya
      };

      while (retries < maxRetries) {
        try {
          const statusResp = await checkSearchStatus(taskId);
          console.log(`Polling check ${retries}: phase=${statusResp.phase}, sources=${statusResp.sources?.length || 0}`);
          
          // Jika phase berubah ke answer atau completed, dapatkan answer lengkap
          if ((statusResp.phase === 'answer' || statusResp.phase === 'completed') && statusResp.answer) {
            console.log(`${statusResp.phase} ready, updating UI`);
            // Perbarui result dengan jawaban lengkap
            setResult(prev => ({
              ...prev!,
              answer: statusResp.answer || '',
              bibliography: (statusResp.bibliography || []).filter((b: any) => typeof b === 'string'),
              phase: statusResp.phase,
              answerPending: false
            }));
            setSearchState("complete");
            break;
          }
          
          // Jika sources bertambah, update referensi
          if (statusResp.phase === 'sources' && statusResp.sources && statusResp.sources.length > 0) {
            console.log(`Updating sources: ${statusResp.sources.length} items`);
            setResult(prev => {
              // Hanya update sources jika jumlahnya bertambah
              if (!prev || statusResp.sources.length > prev.references.length) {
                return {
                  ...prev!,
                  references: statusResp.sources.map(normalizeSource),
                };
              }
              return prev;
            });
          }
          
          // Update progress animation
          setProgress(60 + Math.min(39, retries));
        } catch (error) {
          console.warn("Answer polling error:", error);
        }
        
        retries++;
        await new Promise(r => setTimeout(r, getDelay(retries)));
      }
      
      // Pastikan UI menyelesaikan loading meskipun polling timeout
      setProgress(100);
      setSearchState("complete");
    };
    
    const fetchResults = async () => {
      // Simulate searching phase, tapi mulai polling sources lebih awal
      setSearchState("searching");
      
      // Mulai initial polling untuk sources sebelum menyelesaikan animasi
      let taskIdEarly: string | null = null;
      let sourcesFound = false;
      
      // Promise untuk animasi UI
      const uiAnimation = new Promise<void>(async (resolve) => {
        for (let i = 0; i <= 30; i++) {
          setProgress(i);
          await new Promise((r) => setTimeout(r, 30)); // Dipercepat dari 50ms ke 30ms
        }
        resolve();
      });
      
      // Promise untuk mendapatkan sources lewat early polling
      const earlySourcesPolling = async () => {
        try {
          // Dapatkan task ID dulu
          const initialResponse = await searchJournals(query, startYear, endYear, mode);
          taskIdEarly = initialResponse.taskId || null;
          
          // Jika sudah dapat sources, langsung return
          if (initialResponse.references && initialResponse.references.length > 0) {
            console.log("Sources available immediately!");
            sourcesFound = true;
            return {
              answer: initialResponse.answer || '',
              references: initialResponse.references || [],
              bibliography: Array.isArray(initialResponse.bibliography) ? initialResponse.bibliography : [],
              taskId: initialResponse.taskId,
              phase: initialResponse.phase as 'waiting' | 'sources' | 'answer' | 'completed',
              answerPending: Boolean(initialResponse.answerPending)
            };
          }
          
          // Jika belum, mulai polling agresif
          if (taskIdEarly) {
            console.log("Starting aggressive early polling for sources");
            let attempts = 0;
            while (attempts < 15 && !sourcesFound) { // Lebih banyak percobaan
              await new Promise(r => setTimeout(r, 100)); // Poll lebih cepat, setiap 100ms
              const status = await checkSearchStatus(taskIdEarly);
              attempts++;
              
              if (status.phase === 'sources' && status.sources && status.sources.length > 0) {
                console.log(`Early sources found after ${attempts} attempts!`);
                sourcesFound = true;
                return {
                  answer: '',  // Ensure answer is always a string, not null
                  references: status.sources.map(normalizeSource),
                  taskId: taskIdEarly,
                  phase: 'sources' as 'waiting' | 'sources' | 'answer' | 'completed',
                  answerPending: true
                };
              }
              
              if (status.phase === 'answer' || status.phase === 'completed') {
                console.log(`${status.phase} ready in early polling`);
                sourcesFound = true;
                return {
                  answer: status.answer || '',
                  references: status.sources?.map(normalizeSource) || [],
                  bibliography: status.bibliography || [],
                  taskId: taskIdEarly,
                  phase: status.phase as 'waiting' | 'sources' | 'answer' | 'completed',
                  answerPending: false
                };
              }
            }
          }
          
          return null; // Tidak berhasil mendapatkan sources dalam early polling
        } catch (error) {
          console.warn("Early polling error:", error);
          return null;
        }
      };
      
      try {
        // Tunggu animasi UI dan early polling selesai
        const [_, earlyResult] = await Promise.all([uiAnimation, earlySourcesPolling()]);
        
        // Jika early polling berhasil, gunakan hasilnya
        if (earlyResult) {
          console.log("Using early polling result");
          
          // Pastikan tipe earlyResult sesuai dengan yang diharapkan
          const typedResult = {
            answer: earlyResult.answer || '',
            references: earlyResult.references || [],
            bibliography: Array.isArray(earlyResult.bibliography) ? earlyResult.bibliography : [],
            taskId: earlyResult.taskId,
            phase: earlyResult.phase as 'waiting' | 'sources' | 'answer' | 'completed',
            answerPending: Boolean(earlyResult.answerPending)
          };
          
          setResult(typedResult);
          
          // Periksa fase pencarian saat ini berdasarkan earlyResult
          if (typedResult.phase === 'waiting') {
            setSearchState("searching");
            setJournalsFound(0);
          } else if (typedResult.phase === 'sources') {
            setSearchState("found");
            setJournalsFound(typedResult.references.length);
            setProgress(60);
            
            // Tunjukkan referensi dan mulai polling di background jika answer tertunda
            if (typedResult.answerPending && typedResult.taskId) {
              setSearchState("processing");
              pollAnswerInBackground(typedResult.taskId);
            } else {
              setSearchState("complete");
            }
          } else if (typedResult.phase === 'answer' || typedResult.phase === 'completed') {
            // Phase answer atau completed, sudah selesai
            setSearchState("complete");
            setProgress(100);
          } else {
            // Fallback
            setSearchState("complete");
          }
        } else {
          // Jika early polling gagal, lakukan request normal
          console.log("Early polling did not find sources, doing regular request");
          const data = await searchJournals(query, startYear, endYear, mode);
          
          // Pastikan tipe data sesuai dengan yang diharapkan
          const typedData = {
            answer: data.answer || '',
            references: data.references || [],
            bibliography: Array.isArray(data.bibliography) ? data.bibliography : [],
            taskId: data.taskId,
            phase: data.phase as 'waiting' | 'sources' | 'answer' | 'completed',
            answerPending: Boolean(data.answerPending)
          };
          
          setResult(typedData);

          // Periksa fase pencarian saat ini
          if (typedData.phase === 'waiting') {
            setSearchState("searching");
            setJournalsFound(0);
          } else if (typedData.phase === 'sources') {
            setSearchState("found");
            setJournalsFound(typedData.references.length);
            setProgress(60);
            
            // Tunjukkan referensi dan mulai polling di background jika answer tertunda
            if (typedData.answerPending && typedData.taskId) {
              setSearchState("processing");
              pollAnswerInBackground(typedData.taskId);
            } else {
              setSearchState("complete");
            }
          } else if (typedData.phase === 'answer' || typedData.phase === 'completed') {
            // Phase answer atau completed, sudah selesai
            setSearchState("complete");
            setProgress(100);
          } else {
            // Fallback
            setSearchState("complete");
          }
        }
      } catch (error) {
        console.error("Search error:", error);
        setSearchState("complete"); // Tampilkan fallback result
      }
    };

    fetchResults();
  }, [query, startYear, endYear, mode]);

  // Tampilkan referensi segera saat sources tersedia, tapi jawaban masih loading
  if (searchState !== "complete" && (!result || !result.references || result.references.length === 0)) {
    return (
      <SearchProgress
        state={searchState}
        progress={progress}
        journalsFound={journalsFound}
      />
    );
  }

  if (!result) {
    return (
      <div className="mt-8 p-6 bg-white rounded-lg shadow-sm border border-gray-100 text-center">
        <p className="text-gray-600">
          Tidak ada hasil ditemukan. Silakan coba kueri pencarian yang berbeda.
        </p>
      </div>
    );
  }

  const { answer, references, bibliography } = result;
  const isAnswerPending = result.answerPending || searchState !== "complete";

  return (
    <div className="mt-8 space-y-6">
      {/* AI-generated answer section - kembali ditampilkan paling atas */}
      <div className="bg-white rounded-lg shadow-sm border border-gray-100 p-6">
        <h2 className="text-xl font-semibold mb-4">
          Jawaban Pencarian
          {isAnswerPending && (
            <span className="text-blue-500 text-sm ml-2 font-normal animate-pulse">
              (memproses...)
            </span>
          )}
        </h2>
        
        {!answer && isAnswerPending && (
          <div className="p-4 rounded-md bg-gray-50 border border-gray-100">
            <p className="text-gray-500">Menghasilkan jawaban berdasarkan sumber-sumber yang ditemukan...</p>
          </div>
        )}
        
        {answer && (
          <div className="prose max-w-none">
            <div 
              dangerouslySetInnerHTML={{ __html: formatAnswerText(answer, query) }} 
            />
          </div>
        )}
      </div>

      {/* References section - ditampilkan kedua */}
      <div className="bg-white rounded-lg shadow-sm border border-gray-100 p-6">
        <h2 className="text-xl font-semibold mb-4">Referensi</h2>
        <div className="space-y-4">
          {references.map((reference, index) => (
            <Reference 
              key={index} 
              reference={reference} 
              index={index} 
              taskId={result.taskId}
              bibliography={bibliography}
            />
          ))}

          {references.length === 0 && (
            <p className="text-gray-600 text-center py-4">
              Tidak ada referensi ditemukan untuk pencarian ini.
            </p>
          )}
        </div>
      </div>

      {/* Bibliography section - hanya tampil jika answer sudah selesai */}
      {!isAnswerPending && bibliography && bibliography.length > 0 && (
        <div className="bg-white rounded-lg shadow-sm border border-gray-100 p-6">
          <h2 className="text-xl font-semibold mb-4">Bibliografi</h2>
          <div className="space-y-2 text-sm">
            {bibliography.map((entry, index) => (
              <div key={index} className="pl-8 -indent-8">{entry}</div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}

function SearchProgress({
  state,
  progress,
  journalsFound,
}: {
  state: "searching" | "found" | "processing" | "complete";
  progress: number;
  journalsFound: number;
}) {
  return (
    <div className="mt-8 p-6 bg-white rounded-lg shadow-sm border border-gray-100">
      <div className="flex flex-col items-center mb-6">
        <h2 className="text-lg font-medium text-center mb-2">Menganalisis sumber akademis...</h2>
        <div className="flex items-center justify-center gap-2 mb-1">
          <span className="font-semibold text-violet-600 text-xl">{journalsFound}</span>
          <span className="text-gray-600">jurnal ditemukan</span>
        </div>
        <div className="text-sm font-medium text-gray-500 mb-2">{progress}% selesai</div>
      </div>

      <div className="relative h-2 bg-violet-100 rounded-full overflow-hidden">
        <div
          className="absolute top-0 left-0 h-full bg-violet-600 transition-all duration-300 ease-in-out"
          style={{ width: `${progress}%` }}
        />
      </div>

      <div className="flex justify-between mt-6 px-2 sm:px-6">
        <div className="flex flex-col items-center gap-1">
          <div
            className={cn(
              "w-8 h-8 rounded-full flex items-center justify-center transition-all duration-300",
              state === "searching" ? "bg-violet-600 scale-110" : state === "found" || state === "processing" || state === "complete" ? "bg-green-500" : "bg-gray-200"
            )}
          >
            {state === "searching" ? (
              <Search className="h-4 w-4 text-white animate-pulse" />
            ) : (
              <CheckCircle2 className="h-4 w-4 text-white" />
            )}
          </div>
          <span
            className={cn(
              "text-xs text-center",
              state === "searching"
                ? "text-violet-600 font-medium"
                : state === "found" || state === "processing" || state === "complete"
                  ? "text-green-500 font-medium"
                  : "text-gray-400"
            )}
          >
            Pencarian
          </span>
          </div>

        <div className="flex flex-col items-center gap-1">
          <div
            className={cn(
              "w-8 h-8 rounded-full flex items-center justify-center transition-all duration-300",
              state === "found" ? "bg-violet-600 scale-110" : state === "processing" || state === "complete" ? "bg-green-500" : "bg-gray-200"
            )}
          >
            {state === "found" ? (
              <Search className="h-4 w-4 text-white animate-pulse" />
            ) : state === "processing" || state === "complete" ? (
              <CheckCircle2 className="h-4 w-4 text-white" />
            ) : null}
          </div>
          <span
            className={cn(
              "text-xs text-center",
              state === "found"
                ? "text-violet-600 font-medium"
                : state === "processing" || state === "complete"
                  ? "text-green-500 font-medium"
                  : "text-gray-400"
            )}
          >
            Sumber<br/>Ditemukan
          </span>
        </div>

        <div className="flex flex-col items-center gap-1">
          <div
            className={cn(
              "w-8 h-8 rounded-full flex items-center justify-center transition-all duration-300",
              state === "processing" ? "bg-violet-600 scale-110" : state === "complete" ? "bg-green-500" : "bg-gray-200"
            )}
          >
            {state === "processing" ? (
              <Brain className="h-4 w-4 text-white animate-pulse" />
            ) : state === "complete" ? (
              <CheckCircle2 className="h-4 w-4 text-white" />
            ) : null}
          </div>
          <span
            className={cn(
              "text-xs text-center",
              state === "processing"
                ? "text-violet-600 font-medium"
                : state === "complete"
                  ? "text-green-500 font-medium"
                  : "text-gray-400"
            )}
          >
            Mengolah<br/>Data
          </span>
        </div>
      </div>

      <div className="mt-8 flex justify-center">
        {state === "searching" && (
          <div className="animate-pulse flex flex-col items-center">
            <div className="h-12 w-12 bg-blue-100 rounded-full flex items-center justify-center mb-2">
              <Search className="h-6 w-6 text-blue-600 animate-bounce" />
            </div>
            <p className="text-sm text-gray-600 font-medium">Mencari jurnal ilmiah...</p>
          </div>
        )}
        
        {state === "found" && (
          <div className="animate-pulse flex flex-col items-center">
            <div className="h-12 w-12 bg-blue-100 rounded-full flex items-center justify-center mb-2">
              <Search className="h-6 w-6 text-blue-600 animate-bounce" />
            </div>
            <p className="text-sm text-gray-600 font-medium">Mengumpulkan sumber akademis...</p>
          </div>
        )}
        
        {state === "processing" && (
          <div className="animate-pulse flex flex-col items-center">
            <div className="h-12 w-12 bg-blue-100 rounded-full flex items-center justify-center mb-2">
              <Brain className="h-6 w-6 text-blue-600 animate-bounce" />
            </div>
            <p className="text-sm text-gray-600 font-medium">Menganalisis konten...</p>
          </div>
        )}
      </div>
    </div>
  );
}

function Reference({
  reference,
  index,
  taskId,
  bibliography: allBibliography,
}: {
  reference: JournalReference;
  index: number;
  taskId?: string;
  bibliography?: string[];
}) {
  const [showBibliography, setShowBibliography] = useState(false);
  
  // Handle missing data in reference
  const safeReference = {
    title: reference.title || "No Title",
    authors: reference.authors || ["Unknown Author"],
    year: reference.year || "n.d.",
    journal: reference.journal || "No Journal",
    abstract: reference.abstract || "",
    pdfUrl: reference.pdfUrl || "",
    url: reference.url || "",
  };
  
  // Get bibliography entry that matches this reference's index
  const getBibliographyEntry = (): string => {
    if (!allBibliography || allBibliography.length === 0) {
      // Jika tidak ada data bibliography, gunakan format fallback
      return `${safeReference.authors.join(', ')}. (${safeReference.year}). ${safeReference.title}. ${safeReference.journal}.`;
    }
    
    // Jika bibliografi tersedia berdasarkan urutan indeks, gunakan itu
    if (allBibliography[index] && typeof allBibliography[index] === 'string') {
      return allBibliography[index];
    }
    
    // Jika tidak sesuai indeks, coba temukan berdasarkan konten
    // Cari entri bibliography yang cocok dengan referensi ini
    const titleLower = safeReference.title.toLowerCase();
    const authorLastNames = safeReference.authors.map(author => {
      const nameParts = author.split(' ');
      return nameParts[nameParts.length - 1].toLowerCase();
    });
    const yearStr = safeReference.year.toString();
    
    // Coba temukan kecocokan berdasarkan judul, penulis, atau tahun
    const matchingEntry = allBibliography.find(entry => {
      // Pastikan entry adalah string
      if (!entry || typeof entry !== 'string') return false;
      
      try {
        const entryLower = entry.toLowerCase();
        
        // Periksa kecocokan judul (lebih diprioritaskan)
        if (entryLower.includes(titleLower)) {
          return true;
        }
        
        // Periksa kecocokan nama penulis DAN tahun untuk konfirmasi
        const hasYear = entryLower.includes(yearStr);
        if (hasYear) {
          // Periksa jika nama penulis ada dalam entri
          return authorLastNames.some(name => entryLower.includes(name));
        }
      } catch (e) {
        console.error("Error processing bibliography entry:", e);
        return false;
      }
      
      return false;
    });
    
    // Gunakan entri yang cocok atau fallback ke format standar
    return matchingEntry || `${safeReference.authors.join(', ')}. (${safeReference.year}). ${safeReference.title}. ${safeReference.journal}.`;
  };
  
  // Get bibliography entry for this reference
  const bibliographyEntry = getBibliographyEntry();
  
  // Toggle bibliography visibility
  const toggleBibliography = () => {
    setShowBibliography(!showBibliography);
  };

  return (
    <div className="border border-gray-200 rounded-lg p-4 hover:shadow-md transition-shadow">
      <div className="flex justify-between items-start">
        <div className="flex-1">
          <h3 className="font-medium text-lg">{safeReference.title}</h3>
          <p className="text-gray-600 mt-1">
            {safeReference.authors.join(", ")} ({safeReference.year})
          </p>
          <p className="journal-name text-sm mt-1">
            {safeReference.journal}
          </p>
          
          {/* External links - PDF and URL */}
          {(safeReference.pdfUrl || safeReference.url) && (
            <div className="flex space-x-2 mt-2">
              {safeReference.pdfUrl && (
                <a 
                  href={safeReference.pdfUrl} 
                  target="_blank" 
                  rel="noopener noreferrer"
                  className="inline-flex items-center px-2.5 py-1 rounded-md bg-red-50 text-red-700 text-xs hover:bg-red-100 transition-colors border border-red-200"
                >
                  <Download size={14} className="mr-1" />
                  PDF
                </a>
              )}
              {safeReference.url && (
                <a 
                  href={safeReference.url} 
                  target="_blank" 
                  rel="noopener noreferrer"
                  className="inline-flex items-center px-2.5 py-1 rounded-md bg-blue-50 text-blue-700 text-xs hover:bg-blue-100 transition-colors border border-blue-200"
                >
                  <ExternalLink size={14} className="mr-1" />
                  Link
                </a>
              )}
            </div>
          )}
          
          <div className="mt-2 bg-gray-50 p-3 border-l-2 border-blue-500">
            <div className="text-gray-700 text-sm">
              {safeReference.abstract ? (
                <>
                  <p className="reference-abstract mb-2">"{safeReference.abstract}"</p>
                </>
              ) : (
                <p className="reference-abstract">"{safeReference.journal}"</p>
              )}
            </div>
          </div>
          
          {/* Bibliography section toggle button */}
          <div className="mt-3">
            <button
              onClick={toggleBibliography}
              className="text-xs text-blue-600 hover:text-blue-800 flex items-center"
            >
              {showBibliography ? "Sembunyikan Daftar Pustaka" : "Tampilkan Daftar Pustaka"}
              <span className="ml-1 text-xs">
                {showBibliography ? "▲" : "▼"}
              </span>
            </button>
            
            {/* Bibliography content */}
            {showBibliography && (
              <div className="mt-2 bg-gray-50 p-3 rounded-md border border-gray-200 text-sm">
                <h4 className="font-medium mb-2 text-xs text-gray-600">Daftar Pustaka:</h4>
                <ul className="list-disc pl-4 space-y-2">
                  <li className="text-xs text-gray-700">{bibliographyEntry}</li>
                </ul>
              </div>
            )}
          </div>
        </div>
        <div className="ml-4 flex flex-col items-center justify-center bg-gray-50 rounded-lg p-3 text-center min-w-[60px]">
          <span className="text-2xl font-bold text-blue-600">{index + 1}</span>
          <span className="text-xs text-gray-500">Ref</span>
        </div>
      </div>
      
      {/* Abstrak sudah ditampilkan lengkap di atas, tidak perlu modal */}
    </div>
  );
}

// Function to format answer text with comprehensive markdown styling
function formatAnswerText(text: string, query?: string): string {
  try {
    // Preprocessing untuk formatting khusus
    // 1. Deteksi teks bold dengan ** yang tidak terformat dengan benar di Markdown
    text = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');

    // 2. Konversi URL yang belum menjadi link
    const urlRegex = /(?<![\[\(])(https?:\/\/[^\s"]+)(?![\]\)])/g;
    text = text.replace(urlRegex, '[$1]($1)');

    // Konfigurasi Marked
    // @ts-ignore - Marked tipe tidak lengkap
    marked.setOptions({
      gfm: true,                // GitHub flavored markdown
      breaks: true,             // Convert \n to <br>
    });
    
    // Proses markdown menjadi HTML
    const htmlContent = marked.parse(text) as string;
    
    // Processor untuk menambahkan kelas CSS ke elemen HTML
    const processHTML = (html: string): string => {
      let processedHTML = html;
      
      // Paragraf dengan text-justify
      processedHTML = processedHTML.replace(/<p>/g, '<p class="text-justify mb-4">');
      
      // Heading dengan ukuran dan spacing yang tepat
      processedHTML = processedHTML.replace(/<h1>/g, '<h1 class="text-2xl font-semibold mt-6 mb-4">');
      processedHTML = processedHTML.replace(/<h2>/g, '<h2 class="text-xl font-semibold mt-5 mb-3">');
      processedHTML = processedHTML.replace(/<h3>/g, '<h3 class="text-lg font-semibold mt-4 mb-3">');
      processedHTML = processedHTML.replace(/<h4>/g, '<h4 class="text-base font-semibold mt-4 mb-2">');
      processedHTML = processedHTML.replace(/<h5>/g, '<h5 class="text-sm font-semibold mt-3 mb-2">');
      processedHTML = processedHTML.replace(/<h6>/g, '<h6 class="text-xs font-semibold mt-3 mb-2">');
      
      // List dengan proper indentation dan spacing
      processedHTML = processedHTML.replace(/<ul>/g, '<ul class="list-disc pl-6 my-4">');
      processedHTML = processedHTML.replace(/<ol>/g, '<ol class="list-decimal pl-6 my-4">');
      processedHTML = processedHTML.replace(/<li>/g, '<li class="mb-1">');
      
      // Code blocks dengan syntax highlighting styling
      processedHTML = processedHTML.replace(/<pre>/g, '<pre class="bg-gray-100 p-3 rounded my-4 overflow-auto text-sm">');
      processedHTML = processedHTML.replace(/<code>/g, '<code class="font-mono text-sm bg-gray-100 px-1 py-0.5 rounded">');
      
      // Blockquote dengan styling yang lebih jelas
      processedHTML = processedHTML.replace(/<blockquote>/g, '<blockquote class="border-l-4 border-gray-300 pl-4 py-1 my-4 italic text-gray-700">');
      
      // Table styling
      processedHTML = processedHTML.replace(/<table>/g, '<table class="min-w-full border border-gray-200 my-4">');
      processedHTML = processedHTML.replace(/<thead>/g, '<thead class="bg-gray-100">');
      processedHTML = processedHTML.replace(/<th>/g, '<th class="border border-gray-200 px-4 py-2 text-left">');
      processedHTML = processedHTML.replace(/<td>/g, '<td class="border border-gray-200 px-4 py-2">');
      
      // Link styling
      processedHTML = processedHTML.replace(/<a /g, '<a class="text-blue-600 hover:underline" ');
      
      // Image styling
      processedHTML = processedHTML.replace(/<img /g, '<img class="max-w-full h-auto my-4 rounded" ');
      
      // Horizontal rule
      processedHTML = processedHTML.replace(/<hr>/g, '<hr class="my-6 border-t border-gray-300">');
      
      // Highlight kata kunci pencarian jika ada
      if (query && query.trim().length > 0) {
        const keywords = query.trim().split(/\s+/)
          .filter(word => word.length > 3) // Hanya kata dengan panjang > 3 huruf
          .map(word => word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')) // Escape regex special chars
          .join('|');
        
        if (keywords) {
          const regex = new RegExp(`(${keywords})`, 'gi');
          // Hanya highlight teks di luar tag HTML
          processedHTML = processedHTML.replace(
            /(<[^>]*>|[^<]+)/g,
            match => {
              // Jika bukan tag HTML, lakukan highlighting
              if (!match.startsWith('<') && !match.endsWith('>')) {
                return match.replace(
                  regex, 
                  '<span class="bg-yellow-100 rounded px-0.5">$1</span>'
                );
              }
              return match;
            }
          );
        }
      }
      
      return processedHTML;
    };

    const processedHTML = processHTML(htmlContent);

    // Wrap the entire content in a div with a class for global styling
    return `<div class="text-gray-800 search-results-content">${processedHTML}</div>`;
  } catch (error) {
    console.error('Error parsing markdown:', error);
    // Fallback dengan minimal formatting untuk handling error
    const safeText = text
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/\n\n/g, '</p><p class="text-justify mb-4">') // Paragraf
      .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>'); // Bold text
      
    return `<div class="text-gray-800 search-results-content"><p class="text-justify mb-4">${safeText}</p></div>`;
  }
}
